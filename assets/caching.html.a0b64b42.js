import{_ as s,r as n,o as r,c,a as e,b as o,d as t,e as d}from"./app.d739b443.js";const h={},l=e("h1",{id:"caching",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#caching","aria-hidden":"true"},"#"),t(" Caching")],-1),u=e("h2",{id:"optimizations",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#optimizations","aria-hidden":"true"},"#"),t(" Optimizations")],-1),p={id:"only-cache-what-is-needed-by-your-application",tabindex:"-1"},_=e("a",{class:"header-anchor",href:"#only-cache-what-is-needed-by-your-application","aria-hidden":"true"},"#",-1),m=t(),y=t(" Only Cache What is Needed By Your Application"),f=t("Create custom "),b={href:"https://docs.microsoft.com/en-us/aspnet/web-api/overview/data/using-web-api-with-entity-framework/part-5",target:"_blank",rel:"noopener noreferrer"},g=t("Data Transfer Object"),w=t(" (DTO) C# classes or "),v={href:"https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/records",target:"_blank",rel:"noopener noreferrer"},x=t("record types"),I=e("li",null,[t("Map "),e("code",null,"TreeNode"),t(" and "),e("code",null,"BaseInfo"),t(" objects retrieved from the database into your custom types")],-1),T=e("li",null,"Insert these custom types into the cache",-1),k=e("p",null,[e("strong",null,"Why?")],-1),N=e("code",null,"TreeNode",-1),B=t(" and "),q=e("code",null,"BaseInfo",-1),C=t(" objects are strongly typed wrappers around a "),S={href:"https://docs.microsoft.com/en-us/dotnet/api/system.data.dataset?view=net-6.0",target:"_blank",rel:"noopener noreferrer"},j=t("DataSet"),D=t(" but the values of that underlying "),E=e("code",null,"DataSet",-1),O=t(" are populated based on the query that was used to retrieve data from the database."),z=d('<p>They do not change their API based on what they contain, which means they are good at modeling what <em>might</em> be in the database but poor at modeling what <em>is</em> in memory in your application at any given time.</p><p><strong>Why?</strong></p><p>If you are using <code>TreeNode</code> and <code>BaseInfo</code> objects in a part of your code that is far from where the database query occurred it can be very difficult to trust that the objects contain the fields you expect.</p><p>They could contain <em>less</em> data than was expected and when your application uses the cached data it will not function correctly.</p><p>Custom DTOs let you define which fields are required for your application to function correctly, ensuring the cached data is correct and consistent.</p><p><strong>Why?</strong></p><p><code>TreeNode</code> and <code>BaseInfo</code> objects could also contain <em>more</em> data than was required, in which case caching is going to store more data in memory than your application needs.</p><p>Ideally, this is resolved by optimizing your database querying to retrieve less data, but then you might run into the issue mentioned above when <em>less</em> data was available than expected.</p><h2 id="maintainability" tabindex="-1"><a class="header-anchor" href="#maintainability" aria-hidden="true">#</a> Maintainability</h2><ul><li>Implement as cross-cutting concerns via filters or decoration <ul><li>Avoid putting caching in business logic</li></ul></li><li>Don&#39;t construct cache dependency keys via attributes</li><li>Set short cache lifetimes for most queries</li><li>Separate queries from commands (mutations)</li><li>Avoid repositories <ul><li>Try CQRS / Rich domain models / Service layers</li></ul></li></ul>',10);function A(V,W){const i=n("EssentialIcon"),a=n("ExternalLinkIcon");return r(),c("div",null,[l,u,e("h3",p,[_,m,o(i),y]),e("ul",null,[e("li",null,[f,e("a",b,[g,o(a)]),w,e("a",v,[x,o(a)])]),I,T]),k,e("p",null,[N,B,q,C,e("a",S,[j,o(a)]),D,E,O]),z])}var M=s(h,[["render",A],["__file","caching.html.vue"]]);export{M as default};
